name: AI Proxy

on:
  workflow_dispatch:
    inputs:
      action:
        description: '–¢–∏–ø –¥–µ–π—Å—Ç–≤–∏—è'
        required: true
        type: choice
        options:
          - chat
          - create_file
          - update_file
          - read_file
          - run_action
          - list_files
      data:
        description: '–î–∞–Ω–Ω—ã–µ –≤ JSON'
        required: true
        type: string

jobs:
  process:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Process AI request
        env:
          OPENROUTER_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          GH_TOKEN: ${{ secrets.GH_PAT }}
          ACTION: ${{ github.event.inputs.action }}
          DATA: ${{ github.event.inputs.data }}
          REPO: ${{ github.repository }}
        run: |
          # –°–æ–∑–¥–∞–µ–º —Å–∫—Ä–∏–ø—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏
          cat > processor.js << 'EOF'
          const action = process.env.ACTION;
          const data = JSON.parse(process.env.DATA);
          const repo = process.env.REPO;
          
          // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
          function logOutput(type, content) {
            console.log(`=== ${type} START ===`);
            console.log(JSON.stringify(content));
            console.log(`=== ${type} END ===`);
          }
          
          async function main() {
            console.log(`üéØ –í—ã–ø–æ–ª–Ω—è—é –¥–µ–π—Å—Ç–≤–∏–µ: ${action}`);
            
            switch(action) {
              case 'chat':
                await handleChat();
                break;
              case 'create_file':
              case 'update_file':
                await handleFile();
                break;
              case 'read_file':
                await readFile();
                break;
              case 'list_files':
                await listFiles();
                break;
              case 'run_action':
                await runAction();
                break;
              default:
                logOutput('ERROR', { error: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ' });
            }
          }
          
          async function handleChat() {
            try {
              const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${process.env.OPENROUTER_KEY}`,
                  'Content-Type': 'application/json',
                  'HTTP-Referer': 'https://github.com/artemis1987/Privet-mir',
                  'X-Title': 'AI GitHub Admin'
                },
                body: JSON.stringify({
                  model: data.model || 'openai/gpt-3.5-turbo',
                  messages: data.messages || [],
                  temperature: data.temperature || 0.7,
                  max_tokens: 2000
                })
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${await response.text()}`);
              }
              
              const result = await response.json();
              logOutput('AI_RESPONSE', result);
              
            } catch (error) {
              logOutput('ERROR', { error: error.message });
            }
          }
          
          async function handleFile() {
            try {
              let sha = null;
              
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª
              const checkResponse = await fetch(
                `https://api.github.com/repos/${repo}/contents/${data.path}`,
                {
                  headers: {
                    'Authorization': `token ${process.env.GH_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                  }
                }
              );
              
              if (checkResponse.ok && action === 'update_file') {
                const fileData = await checkResponse.json();
                sha = fileData.sha;
              }
              
              // –ö–æ–¥–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ Base64
              const content = Buffer.from(data.content).toString('base64');
              
              const body = {
                message: data.message || `AI: ${action === 'create_file' ? '—Å–æ–∑–¥–∞–Ω–∏–µ' : '–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ'} —Ñ–∞–π–ª–∞`,
                content: content,
                branch: data.branch || 'main'
              };
              
              if (sha) body.sha = sha;
              
              const response = await fetch(
                `https://api.github.com/repos/${repo}/contents/${data.path}`,
                {
                  method: 'PUT',
                  headers: {
                    'Authorization': `token ${process.env.GH_TOKEN}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(body)
                }
              );
              
              const result = await response.json();
              
              logOutput('FILE_RESULT', {
                success: response.ok,
                path: data.path,
                action: action,
                status: response.status,
                result: result
              });
              
            } catch (error) {
              logOutput('ERROR', { error: error.message });
            }
          }
          
          async function readFile() {
            try {
              const response = await fetch(
                `https://api.github.com/repos/${repo}/contents/${data.path}`,
                {
                  headers: {
                    'Authorization': `token ${process.env.GH_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                  }
                }
              );
              
              if (response.ok) {
                const fileData = await response.json();
                const content = Buffer.from(fileData.content, 'base64').toString();
                
                logOutput('FILE_CONTENT', {
                  path: data.path,
                  content: content,
                  sha: fileData.sha,
                  size: fileData.size
                });
              } else {
                logOutput('ERROR', { error: '–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω', status: response.status });
              }
            } catch (error) {
              logOutput('ERROR', { error: error.message });
            }
          }
          
          async function listFiles() {
            try {
              const response = await fetch(
                `https://api.github.com/repos/${repo}/git/trees/${data.branch || 'main'}?recursive=1`,
                {
                  headers: {
                    'Authorization': `token ${process.env.GH_TOKEN}`,
                    'Accept': 'application/vnd.github.v3+json'
                  }
                }
              );
              
              if (response.ok) {
                const tree = await response.json();
                const files = tree.tree
                  .filter(item => item.type === 'blob')
                  .map(item => item.path);
                
                logOutput('FILE_LIST', files);
              }
            } catch (error) {
              logOutput('ERROR', { error: error.message });
            }
          }
          
          async function runAction() {
            try {
              const response = await fetch(
                `https://api.github.com/repos/${repo}/actions/workflows/${data.workflow}/dispatches`,
                {
                  method: 'POST',
                  headers: {
                    'Authorization': `token ${process.env.GH_TOKEN}`,
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    ref: data.branch || 'main',
                    inputs: data.inputs || {}
                  })
                }
              );
              
              logOutput('ACTION_RESULT', {
                success: response.ok,
                status: response.status
              });
              
            } catch (error) {
              logOutput('ERROR', { error: error.message });
            }
          }
          
          main().catch(error => {
            logOutput('ERROR', { error: error.message });
          });
          EOF
          
          # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫—Ä–∏–ø—Ç
          node processor.js
